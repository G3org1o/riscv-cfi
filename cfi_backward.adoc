[[backward]]
== Backward-edge control-flow integrity

A shadow stack is a second stack used to push the link register if it needs to
be spilled on the stack to make a new procedure call.

The shadow stack, similar to the regular stack, grows downwards, i.e. from higher
addresses to lower addresses. Each entry on the shadow stack is `XLEN` wide and
holds the link register value. The `ssp` points to the top of the shadow stack,
i.e. address of the last element pushed on the shadow stack.

[NOTE]
====
Compilers when generating code for a CFI enabled program must protect the link
register, e.g. `x1` and/or `x5`, from arbitrary modification by not emitting
unsafe code sequences.
====

=== Backward-edge CFI instruction encoding

The backward-edge CFI extension introduces the following instructions for shadow
stack operations. All instructions are encoded using the SYSTEM major opcode and
using the `mop.r` and `mop.rr` encodings defined by the Zimop extension.

[width=100%]
[%header, cols="6,<6,>6,<3,>3,<3,>3,<3,>3,<3,>3", grid=rows, frame=none]
|===
|   `(mop.r)`     |`31`    |      `20`      |`19` | `15`|`14` | `12` |`11` | `7`|`6` | `0`
|  mnemonic    2+^|`1.00..0111..`        2+^|`rs1`   2+^|`func3`  2+^|`rd`   2+^|`opcode`
|`sspop x1`    2+^|`100000011100`        2+^|`00000` 2+^|`100`    2+^|`00001`  2+^|`1110011`
|`sspop x5`    2+^|`100000011100`        2+^|`00000` 2+^|`100`    2+^|`00101`  2+^|`1110011`
|`sspopchk x1` 2+^|`100000011100`        2+^|`00001` 2+^|`100`    2+^|`00000`  2+^|`1110011`
|`sspopchk x5` 2+^|`100000011100`        2+^|`00101` 2+^|`100`    2+^|`00000`  2+^|`1110011`
|              2+^|`12`                  2+^|`5`     2+^|`3`      2+^|`5`    2+^|`7`      
|===

Encoding `rd`  as `x0` is not supported for `sspop` and `ssprr`.

[width=100%]
[%header, cols="6,<3,>3,<3,>3,<3,>3,<3,>3,<3,>3,<3,>3", grid=rows, frame=none]
|===
|`(mop.rr)`     |`31`  |  `25`|`24`|`20`  |`19` | `15`|`14` |  `12`|`11` | `7`|`6` | `0`
|mnemonic    2+^|`1.00..1` 2+^|`rs2`   2+^|`rs1`   2+^|`func3`  2+^|`rd`   2+^|`opcode` 
|`ssamoswap` 2+^|`1000001` 2+^|`src`   2+^|`addr`  2+^|`100`    2+^|`dst`  2+^|`1110011`
|`ssprr`     2+^|`1000011` 2+^|`00000` 2+^|`00000` 2+^|`100`    2+^|`dst`  2+^|`1110011`
|`sspush x1` 2+^|`1000101` 2+^|`00001` 2+^|`00000` 2+^|`100`    2+^|`0`    2+^|`1110011`
|`sspush x5` 2+^|`1000101` 2+^|`00101` 2+^|`00000` 2+^|`100`    2+^|`0`    2+^|`1110011`
|            2+^|`7`       2+^|`5`     2+^|`5`     2+^|`3`      2+^|`5`    2+^|`7`      
|===

Encoding `rd` as `x0` is not supported for `ssamoswap` and `ssprr`.
Only `x1` and `x5` encodings are supported as `rd` for `sspop`.
Only `x1` and `x5` encodings are supported as `rs1` for `sspopchk`.
Only `x1` and `x5` encodings are supported as `rs2` for `sspush`.

While any register may be used as link register, conventionally the `x1` or `x5`
register is expected to be as link register. The Zisslpcfi shadow stack
instructions are designed to be most efficient for use of the `x1` and `x5`
registers as the link register.

[NOTE]
====
Return-address prediction stacks are a common feature of high-performance
instruction-fetch units, but require accurate detection of instructions used for
procedure calls and returns to be effective. For RISC-V, hints as to the
instructions` usage are encoded implicitly via the register numbers used. The
return-address stack (RAS) actions to pop and/or push onto the RAS are specified
in Table 2.1 of the Privileged specification.

Use of `x1` or `x5` as the link register allows a program to benefit from the
return-address prediction stacks and avoid additional register movements to use
the shadow stack instructions.
====

When a Zimop encoding is not supported by the Zisslpcfi extension then the
instruction follows its Zimop defined behavior.

When `menvcfg.CFIE` is 0, then Zisslpcfi is not enabled for privilege modes less
than M.

When `V=0` and `menvcfg.CFIE` is 1, then backward-edge CFI is enabled at S-mode.
When `V=0` and `menvcfg.CFIE` is 1, then backward-edge CFI is enabled at U-mode if
`mstatus.UBCFIE` is 1.

When `henvcfg.CFIE` is 0, then Zisslpcfi is not enabled for use when `V=1`.

When `V=1` and `menvcfg.CFIE` and `henvcfg.CFIE` are both 1, then backward-edge
CFI is enabled in VS-mode. When `V=1` and `menvcfg.CFIE` and `henvcfg.CFIE` are
both 1, then backward-edge CFI is enabled in VU-mode if `vsstatus.UBCFIE` is 1.

The term `xBCFIE` is used to determine if backward-edge CFI is enabled at a
privilege level `x` and is defined as follows:

.`xBCFIE` determination
[source, ruby]
----
if ( privilege == M-mode ) 
    xBCFIE = 1
else if ( menvcfg.CFIE == 1 && V == 0 && privilege == S-mode )
    xBCFIE = 1
else if ( menvcfg.CFIE == 1 && V == 0 && privilege == U-mode )
    xBCFIE = mstatus.UBCFIE
else if ( menvcfg.CFIE == 1 && henvcfg.CFIE == 1 && V == 1 && privilege == S-mode )
    xBCFIE = 1
else if ( menvcfg.CFIE == 1 && henvcfg.CFIE == 1 && V == 1 && privilege == U-mode )
    xBCFIE = vsstatus.UBCFIE
else
    xBCFIE = 0
----

When backward-edge CFI is not enabled(`xBCFIE = 0`):

* The instructions defined for backward-edge CFI revert to their Zimop defined
  behavior and write 0 to [rd].

[NOTE]
====
The use of shadow stacks at U-mode must be explicitly enabled per application.
Explicit enable for user mode applications allows an application to invoke
shared libraries that may have shadow stack instructions even when the
application itself has not enabled backward-edge CFI. The shadow stack
instructions invoked in the context of this application revert to their Zimop
defined behavior.

When Zisslpcfi is enabled, the use of backward-edge CFI is always enabled for
use at S-mode. However, it is benign to use an operating system that has not
been compiled with shadow stack instructions. An operating system that does
not use backward-edge CFI for S-mode execution may still enable the
backward-edge CFI use by U-mode.

When Zisslpcfi is implemented, the use of backward-edge CFI is always enabled
at M-mode. However, it is benign to use M-mode firmware that has not been
compiled with shadow stack instructions.
====

[NOTE]
====
When programs using shadow stack instructions are installed on a machine that
supports the CFI extensions but the operating system installed does not enable
the CFI extensions, the program continues to function due to Zimop defined
behavior of writing 0 to [rd] and not causing an illegal instruction exception.

When programs using shadow stack instructions are installed on a machine that
does not support the CFI extensions but support the Zimop extension, the
program continues to function due to Zimop defined behavior of writing 0 to
[rd] and not causing an illegal instruction exception.

On machines that do not support Zimop extension, the instructions cause an
illegal instruction exception. Installing programs that use the shadow stack
instructions on such machines is not supported.
====

=== Push to and Pop from the shadow stack

A push operation is defined as a decrement of the `ssp` by `XLEN` followed by a
write of the link register at the new top of the shadow stack. A pop operation
is defined as a `XLEN` wide read from the current top of the shadow stack
followed by an increment of the `ssp` by `XLEN`.

Usually, shadow stack enabled programs, push the return address onto the regular
stack as well as the shadow stack in the function prologue. Such programs during
returns from functions pop the link register from the data stack and the
shadow copy of the link register from the shadow stack. The two values are then
compared. If the values do not match, it is an indication that a corruption of the
return address variable and the program causes an illegal instruction exception.

To push a link register on the shadow stack, the CFI extension provides a
`sspush` instruction. 

A `sspopchk` instruction is provided to pop the shadow return address value
from the shadow stack and check that the value matches the contents of the
link register. This instruction is expected to be used by programs operating in
shadow stack mode.

The CFI extension additionally provides a `sspop` instruction to pop a return
address from the shadow stack into a link register. This instruction is expected
to be used by programs operating in control stack mode.

[NOTE]
====
Programs may operate in shadow stack mode or in control stack mode. 

When operating in shadow stack mode, the program uses the shadow stack to store
a shadow copy of the link register. Such programs push the link register on
the regular stack as well as the shadow stack in the prologue of the function.
In the epilog, the link register value from the regular stack is compared to the
shadow copy on the shadow stack. Programs operating in shadow stack mode are
portable to implementations that do not support the Zisslpcfi extension. On
implementations where the extension is not supported, the shadow stack
instructions revert to their Zimop defined behavior but the program continues to
function as the link register is also pushed and popped from the regular stack.
Pushing and popping the link register to regular stack allows such programs to
comply with the ABI. The prologue and epilog of a function in shadow stack mode
is as follows:

[source, ruby]
    function_entry:
        addi sp,sp,-8  # push link register x1
        sd x1,(sp)     # on data stack
        #
        # Let the contents of ssp register be 0x0000000121679F8 and
        # XLEN be 64 ssp register holds the address of the top of
        # shadow stack. Let the contents of the link register x1
        # be 0x0000000010252000
        #
        # 0x00000000121679E8:[                  ]
        # 0x00000000121679F0:[                  ]
        # 0x00000000121679F8:[0xrrrrrrrrrrrrrrrr] <- ssp
        #
        sspush x1      # push link register x1 on shadow stack
        #
        # sspush store the source register value to address
        # (ssp - XLEN/8) and updates ssp to (ssp - XLEN/8) - does
        # a push. Following completion of # sspush the ssp value is
        # the new top of stack i.e. 0x0000000121679F0 and the value
        # in x1 is stored at this location
        #
        # 0x00000000121679E8:[                  ]
        # 0x00000000121679F0:[0x0000000010252000] <- ssp
        # 0x00000000121679F8:[0xrrrrrrrrrrrrrrrr]
        #
         :
         : 
        ld x1,(sp)     # pop link register x1 from data stack
        addi sp,sp,8   
        sspopchk x1    # compare link register x1 to shadow
                       # return address; faults if not same
        #
        # sspopchk loads the value from location addressed by ssp and
        # compares the loaded value to the value held in the register
        # source and if the two are identical updates ssp to
        # (ssp + XLEN/8) - does a pop and a check. Following
        # completion of sspopchk the ssp value is the # new top of
        # stack i.e. 0x00000000121679F8
        #
        # 0x00000000121679E8:[                  ]
        # 0x00000000121679F0:[0x0000000010252000]
        # 0x00000000121679F8:[0xrrrrrrrrrrrrrrrr] <- ssp
        #
        ret

Programs operating in the control stack mode store the return address only
on the shadow stack. Such programs are not portable to implementations that do
not support the Zisslpcfi extension. As these programs do not push a return
address on the regular stack, they are not compliant with the ABI. The
prologue and epilog of a function when operating in control stack mode
is as follows:

[source, ruby]
    function_entry:
        #
        # Let the contents of ssp register be 0x19740428 and XLEN be 32
        # ssp register holds the address of the top of shadow stack
        # Let the contents of the link register x1 be 0x19791216
        #
        # 0x19740418:[          ]
        # 0x19740420:[          ]
        # 0x19740428:[0xrrrrrrrr] <- ssp
        #
        sspush x1      # push link register x1 on shadow stack
        #
        # Following sspush the shadow stack and ssp are as follows:
        #
        # 0x19740418:[          ]
        # 0x19740420:[0x19791216] <- ssp
        # 0x19740428:[0xrrrrrrrr]
        #
         :
         : 
        sspop  x1      # pop return address from shadow stack
        #
        # sspop loads the value from location addressed by ssp into
        # destination register and updates ssp to (ssp + XLEN/8)
        # - does a pop. Following completion of sspop the ssp value
        # is the new top of stack i.e. 0x19740428
        #
        # 0x19740418:[          ]
        # 0x19740420:[0x19791216]
        # 0x19740428:[0xrrrrrrrr] <- ssp
        #
        ret

These examples illustrate the use of `x1` register by the ABI as the link
register. Alternatively, the ABI may use `x5` as the link register.

A leaf function, i.e. a function that does not itself make function calls does
not need to push the link register to the shadow stack or pop it from the shadow
stack in either shadow stack mode or in control stack mode. The return value may
be held in the link register itself for the duration of the leaf function
execution.
====

The `sspop` and `sspopchk` instructions perform a load identically to the
existing `LOAD` instruction with the difference that the base is implicitly
`ssp`, the width is implicitly `XLEN`. 

The `sspush` instruction performs a store identically to the existing `STORE`
instruction with the difference that the base is implicitly `ssp`, the width
is implicitly `XLEN`.

The `sspush`, `sspopchk`, and `sspop` require the virtual address in `ssp` to
have a shadow stack attribute (see <<SSMP>>).

Correct execution of `sspush`, `sspopchk`, and `sspop` requires that `ssp`
refers to idempotent memory. If the memory reference by the `ssp` is not
idempotent then the `sspush` instruction causes a store/AMO access fault and the
`sspop`/`sspopchk` instructions cause a load access fault.

If the virtual address in `ssp` is not `XLEN` aligned, the `sspop`/
`sspopchk` instructions cause a load access fault and the `sspush` instruction
causes store/AMO access fault.

[NOTE]
====
Misaligned accesses to shadow stack are not required and enforcing alignment is
more secure to detect errors in the program. An access-fault exception is raised
instead of address-misaligned exception in such cases to indicate fatality and
that the instruction must not be emulated by a trap handler.

The `sspopchk` instruction performs a load followed by a check of the loaded
data value with the link register as source. If the check against the link register
faults and the instruction is restarted by the trap handler, the instruction
will perform the load again. If the memory from which the load is performed is
non-idempotent then the second load may cause unexpected side effects. Shadow
stack instructions require the memory referenced by `ssp` to be idempotent to
avoid such concerns. Locating shadow stacks in non-idempotent memory (e.g.,
non-idempotent device memory) is not an expected usage and requiring memory
referenced by `ssp` to be idempotent does not pose a significant restriction.
====

The operation of the `sspush` instruction is as follows:

.`sspush` operation
[source, ruby]
----
If (xBCFIE = 1)
   *[ssp - (XLEN/8)] = [src]   # Store src value to ssp - XLEN/8
    [ssp] = [ssp] - (XLEN/8)   # decrement ssp by XLEN/8
else
    [dst] = 0
endif
----

The operation of the `sspop` instruction is as follows:

.`sspop` operation
[source, ruby]
----
if (xBCFIE = 1)
    dst   = *[ssp]             # Load dst from address in ssp
                               # Only x1 and x5 may be used as dst
    [ssp] = [ssp] + (XLEN/8)   # Increment ssp by XLEN/8.
else
    [dst] = 0;
endif
----

The operation of the `sspopchk` instruction is as follows:

.`sspopchk` operation
[source, ruby]
----
if (xBCFIE = 1)
    temp  = *[ssp]             # Load temp from address in ssp and
    if temp != [src]           # Compare temp to value in src and
                               # cause an illegal-instruction exception
                               # if they are not bitwise equal.
                               # Only x1 and x5 may be used as src
       Raise illegal-instruction exception
    else
       [ssp] = [ssp] + (XLEN/8)# increment ssp by XLEN/8.
    endif
else
    [dst] = 0;
endif
----

The `ssp` is incremented by `sspop` and `sspopchk` only if the load from
shadow stack completes successfully. The `ssp` is decremented by `sspush` only
if the store to the shadow stack completes successfuly.

[NOTE]
====
Store to load forwarding is a common technique employed by high performance
processor implementations. CFI implementations may prevent forwarding from a
non-shadow-stack store to a `sspop` or to a `sspopchk` instruction. A
non-shadow-stack store causes a fault if done to a page mapped as a shadow
stack. However such determination may be delayed till the PTE has been examined
and thus may be used to transiently forward the data from such stores to a
`sspop` or to a `sspopchk`.
====

[NOTE]
====
A common operation performed on stacks is to unwind them to support constructs
like setjmp/longjmp, C++ exception handling, etc. A program that uses shadow
stacks must unwind both the shadow stack and the stack used to store data.
The unwind function must verify that it does not accidentally unwind past the
bounds of the shadow stack. Shadow stacks are expected to be bounded on each end
using guard pages i.e. pages that do not have a shadow stack attribute. To
detect out of bound unwinding of the shadow stack, the unwind may
be done in maximal increments of 4 KiB and testing that the ssp is still
pointing to a shadow stack page or has unwound into the guard page. The
following examples illustrate the use of backward-edge CFI instructions to
unwind a shadow stack. This example assumes that the setjmp function itself does
not push on to the shadow stack (being a leaf function it is not required to).

[source, ruby]
setjmp() {
    :
    :
    // read and save the shadow stack pointer to jmp_buf
    asm("ssprr %0" : "=r"(cur_ssp):);
    jmp_buf->saved_ssp = cur_ssp;
    :
    :
}
longjmp() {
    :
    // Read current shadow stack pointer and 
    // compute number of call frames to unwind
    asm("ssprr %0" : "=r"(cur_ssp):);
    // Skip the unwind if backward-edge CFI not enabled
    asm("beqz %0, back_cfi_not_enabled" : "=r"(cur_ssp):);
    num_unwind = jmp_buf->saved_ssp - cur_ssp;
    // Unwind the frames in a loop
    while ( num_unwind > 0 ) {
        step = ( num_unwind >= 4096 ) ? 4096 : num_unwind;
        cur_ssp += step;
        num_unwind -= step;
        // write the ssp register with unwound value
        asm("csrw %0, $ssp_csr_num" : "=r"(cur_ssp):);
        // Test if unwound past the shadow stack bounds
        asm("sspush x5");
        asm("sspop x5");
    }
back_cfi_not_enabled:
    :
}
====

=== Read `ssp` into a register

The `ssprr` instruction is provided to move the contents of `ssp` to the destination
register. 

The operation of the `ssprr` instructions is as follows:

.`ssprr` operation
[source, ruby]
----
If (xBCFIE = 1)
    [dst] = [ssp]
else
    [dst] = 0;
endif
----

[NOTE]
====
The property of Zimop writing 0 to the rd when the extension using Zimop is
not present or not enabled may be used by such functions to skip over unwind
actions by dynamically detecting if the backward-edge CFI extension is enabled.

An example sequence such as the following may be used:

[source, ruby]
    ssprr t0                  # mv ssp to t0
    beqz bcfi_not_enabled     # zero is not a valid shadow stack
                              # pointer by convention
    # Shadow stacks enabled
    :
    :
bcfi_not_enabled:
====

=== Atomic Swap from a shadow stack location

The CFI extension defines an `ssamoswap` instruction to atomically swap the `XLEN`
bits of src register with `XLEN` bits on the shadow stack at address in `addr` and
store the value from address in `src` into register `dst`.

The `ssamoswap` is always sequentially consistent and cannot be reordered with
earlier or later memory operations from the same hart. 

The `ssamoswap` requires the virtual address in `addr` to have a shadow stack
attribute (see <<SSMP>>).

If the virtual address is not `XLEN` aligned then `ssamoswap` causes a store/AMO
access-fault exception.

If the memory reference by the `ssp` is not idempotent then `ssamoswap` causes a
store/AMO access fault.

The operation of the `ssamoswap` instructions is as follows:

.`ssamoswap` operation
[source, ruby]
----
If (xBCFIE = 1)
    Perform the following atomically with sequential consistency
        [dst]  = *[addr]
       *[addr] = [src]
else
    [dst] = 0;
endif
----

[NOTE]
====
Stack switching is a common operation in user as well as supervisor
programs. When a stack switch is performed the stack pointer of the currently
active stack is saved into a context data structure and the new stack is made
active by loading a new stack pointer from a context data structure. 

When shadow stacks are enabled for a program, the program needs to additionally
switch the shadow stack pointer. The pointer to the top of the deactivated
shadow stack if held in a context data structure may be susceptible to memory
corruption vulnerabilities. To protect the pointer value the program may then
store it at the top of the shadow stack itself and thus create a checkpoint. 

An example sequence to store and restore the shadow stack pointer is as follows:

[source, ruby]
# The a0 register holds the pointer to the top of the new shadow
# to switch to. The current ssp is first pushed on the current
# shadow stack and the ssp is restored from new shadow stack
save_shadow_stack_pointer:
    ssprr  x5                   # read ssp and push value onto
    sspush x5                   # shadow stack. The [ssp] now
    addi   x5, x5, -(XLEN/8)    # holds ptr+XLEN/8. The [x5] now 
                                # holds ptr. Save away x5
                                # into a context structure to
                                # restore later.
restore_shadow_stack_pointer:
    ssamoswap t0, x0, (a0)      # t0=*[a0] and *[a0]=0
                                # The [a0] should hold ptr'
                                # The [t0] should hold ptr'+XLEN/8
    addi      a0, a0, (XLEN/8)  # a0+XLEN/8 must match to t0
    bne       t0, a0, crash     # if not crash program
    csrw      ssp, t0           # setup new ssp

Further, the program may enforce an invariant that a shadow stack can be active
only on one hart by using the `ssamoswap` when performing the restore from the
checkpoint such that the checkpointed data is zeroed as part of the restore
sequence and multiple hart attempt to restore the checkpointed data only one of
them succeeds.
====

[[SSMP]]
=== Shadow Stack Memory Protection

To protect shadow stack memory the memory is associated with a new page type -
Shadow Stack (SS) page - in the page tables. 

When the `Smepmp` extension is supported the PMP configuration registers are
enhanced to support a shadow stack memory region for use by M-mode.

==== Virtual-Memory system extension for Shadow Stack

The shadow stack memory is protected using page table attributes such that it
cannot be stored to by instructions other than `sspush` and `ssamoswap`. The
`sspop` and `sspopchk` instructions can only load from shadow stack memory.

The shadow stack can be read using all instructions that load from memory. 

Attempting to fetch an instruction from a shadow stack page raises a fetch
page-fault exception.

The encoding `R=0`, `W=1`, and `X=0`, is defined to mean a shadow stack page.
When `menvcfg.CFIE=0`, this encoding continues to be reserved. When `V=1` and 
`henvcfg.CFIE=0`, this encoding continues to be reserved at `VS` and `VU`.

The following faults may occur:

. If the accessed page is a shadow stack page
.. Stores other than `sspush` and `ssamoswap` cause store/AMO access faults.
.. Instructions fetch causes a page fault
. if the accessed page is not a shadow stack page or if the page is in
  non-idempotent memory
.. `ssamoswap` and `sspush` cause a store/AMO access fault
.. `sspop` and `sspopchk` causes a load access fault

[NOTE]
====
Stores other than `sspush` and `ssamoswap` cause an access fault and not a page
fault to indicate fatality. A page fault in such cases would suggest that the
operating system should service that fault and correct the condition; which is
not possible in this case. If a page fault were caused in this case, in order to
determine this fatal condition the page fault handler would have to decode 
the opcode of the instruction that caused the store/AMO page fault in order to resolve that it was
caused by non-shadow-stack-stores to shadow stack pages, rather than a page fault caused
by an `sspush` or `ssamoswap` to a non-resident page (which is a recoverable
condition). Usually, the operating system page fault handler is performance critical. By
causing an access fault instead of a page fault, the operating system can easily
distinguish the fatal/non-recoverable condition from the recoverable page fault.

On implementations where address-misaligned exception is prioritized higher than
access-fault exception, a trap handler handler that emulates misaligned stores
must cause an access-fault exception if the store is not `sspush` or `ssamoswap`
and the store targets a shadow stack page.

Shadow stack instructions cause an access fault if the accessed page is not a
shadow stack page or if the page is in non-idempotent memory to indicate fatality.

Instruction fetch from a shadow stack page causes a page fault as this condition
is clearly distinguished by a unique cause code and is non recoverable.
====

To support these rules, the virtual address translation process specified in
section 4.3.2 of the Privileged Specification cite:[PRIV] is modified as
follows:
[start=3]
3. If `pte.v = 0` or if any bits of encodings that are reserved for future
   standard use are set within `pte`, stop and raise a page-fault exception
   corresponding to the original access type. The encoding `pte.xwr = 010b`
   is not reserved if `menvcfg.CFIE` is 1 or if `V=1` and `henvcfg.CFIE` is 1.
   
4. Otherwise, the PTE is valid. If `pte.r = 1` or `pte.w = 1` or `pte.x = 1`,
   go to step 5. Otherwise, this PTE is a pointer to the next level of the page
   table. Let `i = i - 1`. If `i < 0`, store and raise a page-fault exception
   corresponding to the original access type. Otherwise, let `a = pte.ppn x
   PAGESIZE` and go to step 2.

5. A leaf PTE has been found. If the memory access is by a shadow stack
   instruction and `pte.xwr != 010b` then cause an access-violation exception
   corresponding to the access type. If the memory access is a store/AMO and
   `pte.xwr == 010b` then cause a store/AMO access-violation. If the requested
   memory access is not allowed by the `pte.r`, `pte.w`, `pte.x`, and `pte.u`
   bits, given the current privilege mode and the value of the `SUM` and `MXR`
   fields of the `mstatus` register, stop and raise a page-fault exception
   corresponding to the original access type.

The PMA checks are extended to require memory referenced by `sspush`, `sspop`,
`ssamoswap`, and `sspopchk` to be idempotent.

The `U` and `SUM` bit enforcement is performed normally for shadow stack
instruction initiated memory accesses. The state of the `MXR` bit does not
affect read access to a shadow stack page as the shadow stack page is always
readable by all instructions that load from memory.

Svpbmt extension and Svnapot extensions are supported for shadow stack pages. 

[NOTE]
====
Operating systems should protect against writeable non-shadow-stack alias
virtual-addresses mappings being created to the shadow stack physical memory. 
====

[NOTE]
====
Shadow stacks are expected to be bounded on each end using guard pages such that
there are no two adjacent shadow stacks. Not locating two shadow stacks adjacent
to each other guards against accidentally underflowing or overflowing from one
shadow stack to another. Traditionally, a guard page for a stack is a page that
is inaccessible to the process owning the stack. For shadow stacks, the guard
page may also be a non-shadow-stack page that is otherwise accessible to the
process owning the shadow stack due to the property that shadows stack load and
stores to non-shadow-stack pages lead to an exception.
====

The G-stage address translation and protections are not affected by the shadow
stack extension. When G-stage page tables are active, the `ssamoswap`, `sspop`
and `sspopchk` instructions require that the G-stage page table mapping of the accessed
memory has read permission and that the `ssamoswap` and `sspush` instructions
have write permission. The `xwr == 010b` encoding in the G-stage PTE remains
reserved.

[NOTE]
====
A future extension may define a shadow stack encoding of the G-stage page table to
support use cases such as a hypervisor enforcing shadow stack protections for
virtual-supervisor.
====

[NOTE]
====
All instructions that load from memory are allowed to read the shadow stack. The
shadow stack only holds a copy of the link register as saved on the regular
stack. The ability to read the shadow stack is useful for debug, performance
profiling, and other use cases.
====

[[PMP_SS]]
==== PMP extension for shadow stack

When privilege mode is less than M, the PMP region accessed by `sspush` and
`ssamoswap` must provide write permission and the PMP region accessed by `sspop`
and `sspopchk` must provide read permission.

The M-mode memory accesses by `sspush` and `ssamoswap` instructions test for
write permission in the matching PMP entry when permission checking is required.

The M-mode memory accesses by `sspop` and `sspopchk` instructions test for read
permission in the matching PMP entry when permission checking is required.

When the `Smepmp` extension is implemented, a new WARL field `sspmp` is defined
in the `mseccfg` CSR to identify a PMP entry as the shadow stack memory region
for M-mode accesses.

When `mseccfg.MML` is 1, the `sspmp` field is read-only else it may be written.

When `sspmp` field is implemented and `mseccfg.MML` is 1 the following rules are
additionally enforced for M-mode memory accesses:

* `sspush`, `sspop`, `sspopchk`, and `ssamoswap` instructions must match PMP
   entry `sspmp`.

* Write by instructions other than `sspush` and `ssamoswap` that match PMP entry
  `sspmp` cause an access violation exception.

[NOTE]
====
The PMP region used for the M-mode shadow stack is expected to be made
inaccessible for U-mode and S-mode read and write accesses. Allowing write
access violates the integrity of the shadow stack and allowing read access may
lead to disclosure of M-mode return addresses.
====
