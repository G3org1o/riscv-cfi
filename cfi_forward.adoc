[[forward]]
== Landing pad (Zicfilp)

To enforce forward-edge control-flow integrity, the Zicfilp extension introduces
a landing pad (`lpad`) instruction. The `lpad` instruction that must be placed
at the program locations that are valid targets of indirect jumps or calls. The
`lpad` instruction (See <<LP_INST>>) is encoded using the `AUIPC` major opcode
with `rd=x0`.

To enforce that the target of an indirect call or indirect jump must be a valid
landing pad instruction, the hart maintains an expected landing pad (`ELP`) state
to determine if a landing pad instruction is required at the target of an
indirect call or an indirect jump. The `ELP` state can be one of:

* 0 - `NO_LP_EXPECTED`
* 1 - `LP_EXPECTED`

The `ELP` state is initialized to `NO_LP_EXPECTED` by the hardware upon reset.

The Zicfilp extension, when enabled, determines if an indirect call or an
indirect jump must land on a landing pad, as specified in <<IND_CALL_JMP>>. If
`is_lp_expected` is 1, then the hart updates the `ELP` to `LP_EXPECTED`.

[[IND_CALL_JMP]]
.Landing pad expected determination
[listing]
----
  is_lp_expected = ( (JALR || C.JR || C.JALR) &&
                     (rs1 != x1) && (rs1 != x5) && (rs1 != x7) ) ? 1 : 0;
----

An indirect branch using `JALR`, `C.JALR`, or `C.JR` with `rs1` as `x7` is
termed a software guarded branch. Such branches do not need to land on a
`lpad` instruction and thus do not set `ELP` to `LP_EXPECTED`.

[NOTE]
====
When the register source is a link register and the register destination is `x0`
then its a return from a procedure and does not require a landing pad at the
target.

When the register source and register destination are both link registers then
its a semantically-direct-call. For example, the `call offset` pseudoinstruction
may expand to a two instruction sequence composed of a `lui ra, imm20` or a
`auipc ra, imm20` instruction followed by a `jalr ra, imm12(ra)` instruction
where `ra` is the link register (either `x1` or `x5`). Since the address of the
procedure was not explicitly taken and the computed address is not obtained from
mutable memory, such semantically-direct calls do not require a landing pad to
be placed at the target. Compilers and JITers must only use the
semantically-direct calls only if when the `rs1` was computed as a PC-relative
or an absolute offset to the symbol.

The `tail offset` pseudoinstruction used to tail call a far-away procedure may
also be expanded to a two instruction sequence composed of a `lui x7, imm20` or
`auipc x7, imm20` followed by a `jalr x0, x7`. Since the address of the
procedure was not explicitly taken and the computed address is not obtained from
mutable memory, such semantically-direct tail-calls do not require a landing pad
to be placed at the target.

Software guarded branches may also be used by compilers to generate code for
constructs like switch-cases. When using the software guarded branches, the
compiler is required to ensure it has full control on the possible jump
targets (e.g., by obtaining the targets from a read-only table in memory and
performing bounds checking on the index into the table, etc.).
====

The landing pad may be labeled. Zicfilp extension designates the register `x7`
for use as the landing pad label register. To support labeled landing pads, the
indirect call/jump sites establish an expected landing pad label (e.g., using
the `lui` instruction) in the bits 31:12 of the `x7` register. The `lpad`
instruction is encoded with a 20-bit immediate value called the landing-pad-label
(`LPL`) that is matched to the expected landing pad label. When `LPL` is encoded
as zero, the `lpad` instruction does not perform the label check and in programs
built with this single label mode of operation the indirect call/jump sites do
not need to establish an expected landing pad label value in `x7`.

When `ELP` is set to `LP_EXPECTED`, if the next instruction in the instruction
stream is not 4-byte aligned, or is not `lpad`, or if the landing pad label
encoded in `lpad` is not zero and does not match the expected landing pad label
in bits 31:12 of the `x7` register, then an integrity-fault exception with *tval
set to "landing pad fault (code=2)" is raised else the `ELP` is updated to
`NO_LP_EXPECTED`.

[NOTE]
====
The tracking of `ELP` and the requirement for a landing pad instruction
at the target of indirect call and jump enables a processor implementation to
significantly reduce or to prevent speculation to non-landing-pad instructions.
Constraining speculation using this technique, greatly reduces the gadget space
and increases the difficulty of using techniques such as branch-target-injection,
also known as Spectre variant 2, which use speculative execution to leak data
through side channels.

The `lpad` requires a 4-byte alignment to address the concatenation of two
instructions `A` and `B` accidentally forming an unintended landing pad in the
program. For example, consider a 32-bit instruction where the bytes 3 and 2 have
a pattern of `?017h` (for example, the immediate fields of a `lui`, `auipc`, or
a `jal` instruction), followed by a 16-bit or a 32-bit instruction. When
patterns that can accidentally form a valid landing pad are detected, the
assembler or linker can force instruction `A` to be aligned to a 4-byte
boundary to force the unintended `lpad` pattern to become misaligned and thus
not a valid landing pad or may use an alternate register allocation to prevent
the accidental landing pad.
====

=== Zicfilp CSRs

This chapter specifies the CSR state of the Zicfilp extension.

==== Machine environment configuration registers (`menvcfg and menvcfgh`)

.Machine environment configuration register (`menvcfg`) for MXLEN=64
[wavedrom, ,svg]
....
{reg: [
  {bits:  1, name: 'FIOM'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'LPE'},
  {bits:  1, name: 'WPRI'},
  {bits:  2, name: 'CBIE'},
  {bits:  1, name: 'CBCFE'},
  {bits:  1, name: 'CBZE'},
  {bits: 53, name: 'WPRI'},
  {bits:  1, name: 'HADE'},
  {bits:  1, name: 'PBMTE'},
  {bits:  1, name: 'STCE'},
], config:{lanes: 4, hspace:1024}}
....

Zicfilp extension introduces the `LPE` field (bit 2) in `menvcfg`. When
`LPE` field is 1, the Zicfilp extension is enabled in S-mode. When `LPE`
field is 0, the Zicfilp extension is not enabled in S-mode and the following
rules apply to S-mode:

* The hart does not update the expected landing pad (`ELP`) state and the `ELP`
  state is always `NO_LP_EXPECTED`.
* The `lpad` instruction executes as a no-op.

==== Supervisor environment configuration registers (`senvcfg`)

.Supervisor environment configuration register (`senvcfg`) when `SXLEN=64`
[wavedrom, ,svg]
....
{reg: [
  {bits:  1, name: 'FIOM'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'LPE'},
  {bits:  1, name: 'WPRI'},
  {bits:  2, name: 'CBIE'},
  {bits:  1, name: 'CBCFE'},
  {bits:  1, name: 'CBZE'},
  {bits: 56, name: 'WPRI'},
], config:{lanes: 4, hspace:1024}}
....

Zicfilp extension introduces the `LPE` field (bit 2) in `senvcfg`. When
`LPE` field is 1, the Zicfilp extension is enabled in VU/U-mode. When `LPE`
field is 0, the Zicfilp extension is not enabled in VU/U-mode and the
following rules apply to VU/U-mode:

* The hart does not update the expected landing pad (`ELP`) state and the `ELP`
  state is always `NO_LP_EXPECTED`.
* The `lpad` instruction executes as a no-op.

==== Hypervisor environment configuration registers (`henvcfg and henvcfgh`)

.Hypervisor environment configuration register (`henvcfg`) for MXLEN=64
[wavedrom, ,svg]
....
{reg: [
  {bits:  1, name: 'FIOM'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'LPE'},
  {bits:  1, name: 'WPRI'},
  {bits:  2, name: 'CBIE'},
  {bits:  1, name: 'CBCFE'},
  {bits:  1, name: 'CBZE'},
  {bits: 53, name: 'WPRI'},
  {bits:  1, name: 'HADE'},
  {bits:  1, name: 'PBMTE'},
  {bits:  1, name: 'STCE'},
], config:{lanes: 4, hspace:1024}}
....

Zicfilp extension introduces the `LPE` field (bit 2) in `henvcfg`. When
`LPE` field is 1, the Zicfilp extension is enabled in VS-mode. When `LPE`
field is 0, the Zicfilp extension is not enabled in VS-mode and the following
rules apply to VS-mode:

* The hart does not update the expected landing pad (`ELP`) state and the `ELP`
  state is always `NO_LP_EXPECTED`.
* The `lpad` instruction executes as a no-op.

==== Machine status registers (`mstatus`)

.Machine-mode status register (`mstatus`) for RV64
[wavedrom, ,svg]
....
{reg: [
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SIE'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'MIE'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SPIE'},
  {bits:  1, name: 'UBE'},
  {bits:  1, name: 'MPIE'},
  {bits:  1, name: 'SPP'},
  {bits:  2, name: 'VS[1:0]'},
  {bits:  2, name: 'MPP[1:0]'},
  {bits:  2, name: 'FS[1:0]'},
  {bits:  2, name: 'XS[1:0]'},
  {bits:  1, name: 'MPRV'},
  {bits:  1, name: 'SUM'},
  {bits:  1, name: 'MXR'},
  {bits:  1, name: 'TVM'},
  {bits:  1, name: 'TW'},
  {bits:  1, name: 'TSR'},
  {bits:  1, name: 'SPELP'},
  {bits:  8, name: 'WPRI'},
  {bits:  2, name: 'UXL[1:0]'},
  {bits:  2, name: 'SXL[1:0]'},
  {bits:  1, name: 'SBE'},
  {bits:  1, name: 'MBE'},
  {bits:  3, name: 'WPRI'},
  {bits:  1, name: 'MPELP'},
  {bits: 21, name: 'WPRI'},
  {bits:  1, name: 'SD'},
], config:{lanes: 4, hspace:1024}}
....

The Zicfilp extension introduces the `SPELP` (bit 23) and `MPELP` (bit 41)
fields that hold the previous `ELP`, and are updated as specified in
<<FORWARD_TRAPS>>. The `xPELP` fields are encoded as follows:

* 0 - `NO_LP_EXPECTED` - no landing pad instruction expected.
* 1 - `LP_EXPECTED` - a landing pad instruction is expected.

==== Supervisor status registers (`sstatus`)

.Supervisor-mode status register (`sstatus`) when `SXLEN=64`
[wavedrom, ,svg]
....
{reg: [
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SIE'},
  {bits:  3, name: 'WPRI'},
  {bits:  1, name: 'SPIE'},
  {bits:  1, name: 'UBE'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SPP'},
  {bits:  2, name: 'VS[1:0]'},
  {bits:  2, name: 'WPRI'},
  {bits:  2, name: 'FS[1:0]'},
  {bits:  2, name: 'XS[1:0]'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SUM'},
  {bits:  1, name: 'MXR'},
  {bits:  3, name: 'WPRI'},
  {bits:  1, name: 'SPELP'},
  {bits:  8, name: 'WPRI'},
  {bits:  2, name: 'UXL[1:0]'},
  {bits: 29, name: 'WPRI'},
  {bits:  1, name: 'SD'},
], config:{lanes: 4, hspace:1024}}
....

Access to the `SPELP` field introducecd by Zicfilp accesses the homonymous
fields of `mstatus` when `V=0` and the homonymous fields of `vsstatus`
when `V=1`.

==== Virtual supervisor status registers (`vsstatus`)

.Virtual supervisor status register (`vsstatus`) when `VSXLEN=64`
[wavedrom, ,svg]
....
{reg: [
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SIE'},
  {bits:  3, name: 'WPRI'},
  {bits:  1, name: 'SPIE'},
  {bits:  1, name: 'UBE'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SPP'},
  {bits:  2, name: 'VS[1:0]'},
  {bits:  2, name: 'WPRI'},
  {bits:  2, name: 'FS[1:0]'},
  {bits:  2, name: 'XS[1:0]'},
  {bits:  1, name: 'WPRI'},
  {bits:  1, name: 'SUM'},
  {bits:  1, name: 'MXR'},
  {bits:  3, name: 'WPRI'},
  {bits:  1, name: 'SPELP'},
  {bits:  8, name: 'WPRI'},
  {bits:  2, name: 'UXL[1:0]'},
  {bits: 29, name: 'WPRI'},
  {bits:  1, name: 'SD'},
], config:{lanes: 4, hspace:1024}}
....

The Zicfilp extension introduces the `SPELP` (bit 23) field that hold the
previous `ELP`, and is updated as specified in <<FORWARD_TRAPS>>.
The `SPELP` field is encoded as follows:

* 0 - `NO_LP_EXPECTED` - no landing pad instruction expected.
* 1 - `LP_EXPECTED` - a landing pad instruction is expected.

==== Machine Security Configuration (`mseccfg`)

.Machine security configuration register (`mseccfg`) when `MXLEN=64`
[wavedrom, ,svg]
....
{reg: [
  {bits:  1, name: 'MML'},
  {bits:  1, name: 'MMWP'},
  {bits:  1, name: 'RLB'},
  {bits:  5, name: 'WPRI'},
  {bits:  1, name: 'USEED'},
  {bits:  1, name: 'SSEED'},
  {bits:  1, name: 'MLPE'},
  {bits: 53, name: 'WPRI'},
], config:{lanes: 4, hspace:1024}}
....

The Zicfilp extension introduces the `MLPE` (bit 10) field in `mseccfg`. When
`MLPE` field is 1, Zicfilp extension is enabled in M-mode. When `MLPE` field
is 0, the Zicfilp extension is not enabled in M-mode and the following rules
apply to M-mode.

* The hart does not update the expected landing pad (`ELP`) state and the `ELP`
  state is always `NO_LP_EXPECTED`.
* The `lpad` instruction executes as a no-op.

==== Debug Control and Status (`dcsr`)

.Debug Control and Status (`dcsr`)
[wavedrom, ,svg]
....
{reg: [
  {bits:  2, name: 'prv'},
  {bits:  1, name: 'step'},
  {bits:  1, name: 'nmip'},
  {bits:  1, name: 'mprven'},
  {bits:  1, name: 'v'},
  {bits:  3, name: 'cause'},
  {bits:  1, name: 'stoptime'},
  {bits:  1, name: 'stopcount'},
  {bits:  1, name: 'stepie'},
  {bits:  1, name: 'ebreaku'},
  {bits:  1, name: 'ebreaks'},
  {bits:  1, name: '0'},
  {bits:  1, name: 'ebreakm'},
  {bits:  1, name: 'ebreakvu'},
  {bits:  1, name: 'ebreakvs'},
  {bits:  1, name: 'pelp'},
  {bits:  9, name: '0'},
  {bits:  4, name: 'debugver'},
], config:{lanes: 4, hspace:1024}}
....

The Zicfilp extension introduces the `pelp` (bit 18) in `dcsr`. The `pelp` field
holds the previous `ELP`, and is updated as specified in <<FORWARD_TRAPS>>. The
`pelp` field is encoded as follows:

* 0 - `NO_LP_EXPECTED` - no landing pad instruction expected.
* 1 - `LP_EXPECTED` - a landing pad instruction is expected.

[[FCIFIACT]]
=== Landing-Pad-Enabled (LPE) state

The term `xLPE` is used to determine if forward-edge CFI using landing pads
provided by the Zicfilp extension is enabled at a privilege mode and it is
determined as follows:

.`xLPE` determination
[width=100%]
[%header, cols="^4,^12"]
|===
|Privilege Mode| xLPE
|  M           | `mseccfg.MLPE`
|  S or HS     | `menvcfg.LPE`
|  VS          | `henvcfg.LPE`
|  U or VU     | `senvcfg.LPE`
|===

[NOTE]
====
The Zicfilp must be explicitly enabled for use at each privilege mode.

Programs compiled with the `lpad` instruction continue to function correctly,
but without forward-edge CFI protection, when the Zicfilp extension is not
implemented or is not enabled.
====

[[LP_INST]]
=== Landing pad instruction

When Zicfilp is enabled, `lpad` is the only instruction allowed to execute when
the `ELP` state is `LP_EXPECTED`. If Zicfilp is not enabled then the instruction
is a no-op. If Zicfilp is enabled, the `lpad` instruction causes an
integrity-fault exception with *tval set to "landing pad fault (code=2)" if any
of the following conditions are true:

* The `pc` is not 4-byte aligned.
* The `ELP` is `LP_EXPECTED` and the `LPL` is not zero and the `LPL` does not
  match the expected landing pad label in bits 31:12 of the `x7` register.

If the instruction causes an integrity-fault exception, the `ELP` does not
change. The behavior of the trap caused by this integrity-fault exception is
specified in section <<FORWARD_TRAPS>>. If an integrity-fault exception is
not caused then the `ELP` is updated to `NO_LP_EXPECTED`.

[wavedrom, ,svg]
....
{reg: [
  {bits:  7, name: 'opcode', attr:'AUIPC'},
  {bits:  5, name: 'rd', attr:'00000'},
  {bits: 20, name: 'LPL'},
], config:{lanes: 1, hspace:1024}}
....

The operation of the `lpad` instruction is as follows:

.`lpad` operation
[listing]
----
if (xLPE != 0)
    // If PC not 4-byte aligned then integrity-fault
    if pc[1:0] != 0
        Cause integrity-fault exception
    // If landing pad label not matched -> integrity-fault
    else if (inst.LPL != x7[31:12] && inst.LPL != 0 && ELP == LP_EXPECTED)
        Cause integrity-fault exception
    else
        ELP = NO_LP_EXPECTED
else
    no-op
endif
----

[[FORWARD_TRAPS]]
=== Preserving expected landing pad state on traps

A trap may need to be delivered to the same or to a higher privilege mode upon
completion of `JALR`/`C.JALR`/`C.JR`, but before the instruction at the target
of indirect call/jump was decoded, due to:

* Asynchronous interrupts.
* Synchronous exceptions with priority higher than that of an integrity-fault
  exception with *tval set to "landing pad fault (code=2)" (See Table 3.7 of
  Privileged Specification cite:[PRIV]).

The integrity-fault exception caused by Zicfilp has higher priority than an
illegal-instruction exception but lower priority than instruction access fault.

The integrity-fault exception due to the instruction not being an `lpad`
instruction when `ELP` is `LP_EXPECTED` or an integrity-fault exception
caused by the `lpad` instruction itself (See <<LP_INST>>) leads to a trap being
delivered to the same or to a higher privilege mode.

In such cases, the `ELP` prior to the trap, the previous `ELP`, must be
preserved by the trap delivery such that it can be restored on a return from the
trap. To store the previous `ELP` state on trap delivery to M-mode, a `MPELP`
bit is provided in the `mstatus` CSR. To store the previous `ELP` state on trap
delivery to S/HS-mode, a `SPELP` bit is provided in the `mstatus` CSR. The
`SPELP` bit in `mstatus` can be accessed through the `sstatus` CSR. To store
the previous `ELP` state on traps to VS-mode, a `SPELP` bit is defined in the
`vsstatus` (VS-modes version of `sstatus`). To store the previous `ELP` state on
transition to Debug Mode, a `pelp` bit is defined in the `dcsr` register.

When a trap is taken into privilege mode `x`, the `xPELP` is set to `ELP` and
`ELP` is set to `NO_LP_EXPECTED`.

An `MRET` or `SRET` instruction is used to return from a trap in M-mode or
S-mode, respectively. An `xRET` instruction sets the `ELP` to `xPELP`, and sets
`xPELP` to `NO_LP_EXPECTED`.

Upon entry into Debug Mode, the `pelp` bit in `dcsr` is updated with the `ELP`
at the privilege level the hart was previously in and the `ELP` is set to
`NO_LP_EXPECTED`. When a hart resumes from Debug Mode, the `ELP` is changed to
that specified by `pelp` in `dcsr`.

[NOTE]
====
The trap handler in privilege mode `x` must save the `xPELP` bit and the `x7`
register before performing an indirect call/jump. If the privilege mode `x`
can respond to interrupts, then the trap handler should also save these values
before enabling interrupts.

The trap handler in privilege mode `x` must restore the saved `xPELP` bit and
the `x7` register before executing the `xRET` instruction to return from a
trap.
====
