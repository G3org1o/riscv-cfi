
[[backward]]
== Shadow Stack (Zicfiss)

The Zicfiss extension introduces a shadow stack to enforce backward-edge
control-flow integrity. A shadow stack is a second stack used to store a
shadow copy of the return address in the link register if it needs to be
spilled.

The shadow stack is designed to provide integrity to control transfers performed
using a _return_, where the return may be from a procedure invoked using an
indirect call or a direct call, and this is referred to as backward-edge
protection.

A program using backward-edge control-flow integrity has two stacks: a regular
stack and a shadow stack. The shadow stack is used to spill the link register,
if required, by non-leaf functions. An additional register, shadow-stack-pointer
(`ssp`), is introduced in the architecture to hold the address of the top of the
active shadow stack.

The shadow stack, similar to the regular stack, grows downwards, from
higher addresses to lower addresses. Each entry on the shadow stack is `XLEN`
wide and holds the link register value. The `ssp` points to the top of the
shadow stack, which is the address of the last element stored on the shadow
stack.

The shadow stack is architecturally protected from inadvertent corruptions and
modifications, as detailed later (See <<SSMP>>).

The Zicfiss extension provides instructions to store and load the link register
to/from the shadow stack and to check the integrity of the return address. The
extension provides instructions to support common stack maintenance operations
such as stack unwinding and stack switching.

When Zicfiss is enabled, each function that needs to spill the link register,
typically non-leaf functions, store the link register value to the regular stack
and a shadow copy of the link register value to the shadow stack when the
function is entered (the prologue). When such a function returns (the
epilogue), the function loads the link register from the regular stack and
the shadow copy of the link register from the shadow stack. Then, the link
register value from the regular stack and the shadow link register value from
the shadow stack are compared. A mismatch of the two values is indicative of a
subversion of the return address control variable and causes a software-check
exception.

The Zicfiss instructions are encoded using a subset of May-Be-Operation
instructions defined by the Zimop and Zcmop extensions cite:[ZIMOP]. This subset
of instructions revert to their Zimop/Zcmop defined behavior when the Zicfiss
extension is not implemented or if the extension has not been activated. A
program that is built with Zicfiss instructions can thus continue to operate
correctly, but without backward-edge control-flow integrity, on processors that
do not support the Zicfiss extension or if the Zicfiss extension is not active.
The Zicfiss extension may be activated for use individually and independently
for each privilege mode.

Compilers should flag each object file (for example, using flags in the ELF
attributes) to indicate if the object file has been compiled with the Zicfiss
instructions. The linker should flag (for example, using flags in the ELF
attributes) the binary/executable generated by linking objects as being
compiled with the Zicfiss instructions only if all the object files that are
linked have the same Zicfiss attributes.

The dynamic loader should activate the use of Zicfiss extension for an
application only if all executables (the application and the dependent
dynamically-linked libraries) used by that application use the Zicfiss
extension.

An application that has the Zicfiss extension active may request the dynamic
loader at runtime to load a new dynamic shared object (using dlopen() for
example). If the requested object does not have the Zicfiss attribute then
the dynamic loader, based on its policy (e.g., established by the operating
system or the administrator) configuration, could either deny the request or
deactivate the Zicfiss extension for the application. It is strongly recommended
that the policy enforces a strict security posture and denies the request.

The Zicfiss extension has dependencies on the following extensions: Zicsr,
Zimop, and Zcmop. Additionally, use of Zicfiss in U-mode requires S-mode to be
implemented. Use of Zicfiss in M-mode is not supported.

<<<

=== Zicfiss Instructions Summary

The Zicfiss extension introduces the following instructions:

* Push to the shadow stack (See <<SS_PUSH>>)
** `SSPUSH x1` and `SSPUSH x5` - encoded using `MOP.RR.7`
** `C.SSPUSH x1` - encoded using `C.MOP.1`

* Pop from the shadow stack (See <<SS_POP>>)
** `SSPOPCHK x1` and `SSPOPCHK x5` - encoded using `MOP.R.28`
** `C.SSPOPCHK x5` - encoded using `C.MOP.5`

* Read the value of `ssp` into a register (See <<SSP_READ>>)
** `SSRDP` - encoded using `MOP.R.28`

* Perform an atomic swap from a shadow stack location (See <<SSAMOSWAP>>)
** `SSAMOSWAP.W` and `SSAMOSWAP.D`

When a `MOP.RR.7` or `MOP.R.28` encoding is not utilized by the Zicfiss
extension, the instruction adheres to its Zimop-defined behavior, unless it is
employed by another extension. In such cases, the instruction follows the
behavior specified by that other extension.

If a shadow stack (SS) instruction raises an access-fault, page-fault, or
guest-page-fault exception that is supposed to indicate the original instruction
type (load or store/AMO), then the reported exception cause is respectively a
store/AMO access fault (code 7), a store/AMO page fault (code 15), or a
store/AMO guest-page fault (code 23). For shadow stack instructions, the
reported instruction type is always as though it were a store or AMO, even for
instructions `SSPOPCHK` and `C.SSPOPCHK` that only read from memory and do not
write to it.

[NOTE]
====
When Zicfiss is implemented, the existing "store/AMO" exceptions can be thought
of as "store/AMO/SS" exceptions, indicating that the trapping instruction is
either a store, an AMO, or a shadow stack instruction.
====

[NOTE]
====
The H (hypervisor) extension specifies that when a guest-page fault is caused by
an implicit memory access of VS-stage address translation, the reported
exception is either a load or store/AMO guest-page fault based not on the
original instruction type but rather on whether the memory access attempted for
VS-stage translation was a read or a write of memory. VS-stage address
translation can thus cause a shadow stack instruction to raise a load
guest-page-fault exception.
====

<<<

=== Zicfiss CSRs

This section specifies the CSR state of the Zicfiss extensions.

==== Machine Environment Configuration Register (`menvcfg`)

.Machine environment configuration register (`menvcfg`)
[wavedrom, ,svg]
....
{reg: [
  {bits:  1, name: 'FIOM'},
  {bits:  2, name: 'WPRI'},
  {bits:  1, name: 'SSE'},
  {bits:  2, name: 'CBIE'},
  {bits:  1, name: 'CBCFE'},
  {bits:  1, name: 'CBZE'},
  {bits: 53, name: 'WPRI'},
  {bits:  1, name: 'ADUE'},
  {bits:  1, name: 'PBMTE'},
  {bits:  1, name: 'STCE'},
], config:{lanes: 4, hspace:1024}}
....

The Zicfiss extension adds the `SSE` field (bit 3) to `menvcfg`. When the `SSE`
field is set to 1 the Zicfiss extension is activated in S-mode.

When `SSE` field is 0, the following rules apply to privilege modes that are
less than M:

* 32-bit Zicfiss instructions will revert to their behavior as defined by Zimop.
* 16-bit Zicfiss instructions will revert to their behavior as defined by Zcmop.
* The `pte.xwr=010b` encoding in VS/S-stage page tables becomes reserved.
* The `henvcfg.SSE` and `senvcfg.SSE` fields will read as zero and are read-only.

==== Supervisor Environment Configuration Register (`senvcfg`)

.Supervisor environment configuration register (`senvcfg`)
[wavedrom, ,svg]
....
{reg: [
  {bits:  1, name: 'FIOM'},
  {bits:  2, name: 'WPRI'},
  {bits:  1, name: 'SSE'},
  {bits:  2, name: 'CBIE'},
  {bits:  1, name: 'CBCFE'},
  {bits:  1, name: 'CBZE'},
  {bits: 56, name: 'WPRI'},
], config:{lanes: 4, hspace:1024}}
....

Zicfiss extension introduces the `SSE` field (bit 3) in `senvcfg`. If the
`SSE` field is set to 1, the Zicfiss extension is activated in VU/U-mode. When
the `SSE` field is 0, the Zicfiss extension remains inactive in VU/U-mode, and
the following rules apply:

* 32-bit Zicfiss instructions will revert to their behavior as defined by Zimop.
* 16-bit Zicfiss instructions will revert to their behavior as defined by Zcmop.

<<<

==== Hypervisor Environment Configuration Register (`henvcfg`)

.Hypervisor environment configuration register (`henvcfg`)
[wavedrom, ,svg]
....
{reg: [
  {bits:  1, name: 'FIOM'},
  {bits:  2, name: 'WPRI'},
  {bits:  1, name: 'SSE'},
  {bits:  2, name: 'CBIE'},
  {bits:  1, name: 'CBCFE'},
  {bits:  1, name: 'CBZE'},
  {bits: 53, name: 'WPRI'},
  {bits:  1, name: 'ADUE'},
  {bits:  1, name: 'PBMTE'},
  {bits:  1, name: 'STCE'},
], config:{lanes: 4, hspace:1024}}
....

Zicfiss extension introduces the `SSE` field (bit 3) in `henvcfg`. If the
`SSE` field is set to 1, the Zicfiss extension is activated in VS-mode. When
the `SSE` field is 0, the Zicfiss extension remains inactive in VS-mode, and
the following rules apply when `V=1`:

* 32-bit Zicfiss instructions will revert to their behavior as defined by Zimop.
* 16-bit Zicfiss instructions will revert to their behavior as defined by Zcmop.
* The `pte.xwr=010b` encoding in VS-stage page tables becomes reserved.
* The `senvcfg.SSE` field will read as zero and is read-only.

==== Shadow Stack Pointer (`ssp`)

The `ssp` CSR is an unprivileged read-write (URW) CSR that reads and writes
`XLEN` low order bits of the shadow stack pointer (`ssp`). The CSR address is
0x011. There is no high CSR defined as the `ssp` is always as wide as the `XLEN`
of the current privilege mode. The bits 1:0 of `ssp` are read-only zero. If the
UXLEN or SXLEN may never be 32, then the bit 2 is also read-only zero.

Attempts to access the `ssp` CSR may result in either an illegal-instruction
exception or a virtual instruction exception, contingent upon the state of the
`__x__envcfg.SSE` fields. The conditions are specified as follows:

* If the privilege mode is less than M and `menvcfg.SSE` is 0, an
  illegal-instruction exception is raised.
* Otherwise, if in U-mode and `senvcfg.SSE` is 0, an illegal-instruction
  exception is raised.
* Otherwise, if in VS-mode and `henvcfg.SSE` is 0, a virtual instruction
  exception is raised.
* Otherwise, if in VU-mode and either `henvcfg.SSE` or `senvcfg.SSE` is 0,
  a virtual instruction exception is raised.
* Otherwise, the access is allowed.

<<<

=== Shadow-Stack-Enabled (SSE) State

The term `xSSE` is used to determine if backward-edge CFI using shadow stacks
provided by the Zicfiss extension is enabled at a privilege mode.

When S-mode is implemented, it is determined as follows:

.`xSSE` determination when S-mode is implemented
[width=100%]
[%header, cols="^4,^12"]
|===
|Privilege Mode| `xSSE`
|  M           | `0`
|  S or HS     | `menvcfg.SSE`
|  VS          | `henvcfg.SSE`
|  U or VU     | `senvcfg.SSE`
|===

When S-mode is not implemented, then `xSSE` is 0 at both M and U privilege modes.

[NOTE]
====
Activating Zicfiss in U-mode must be done explicitly per process. Not activating
Zicfiss at U-mode for a process when that application is not compiled with
Zicfiss allows it to invoke shared libraries that may contain Zicfiss
instructions. The Zicfiss instructions in the shared library revert to their
Zimop/Zcmop-defined behavior in this case.

When Zicfiss is enabled in S-mode it is benign to use an operating system that is
not compiled with Zicfiss instructions. Such an operating system that does
not use backward-edge CFI for S-mode execution may still activate Zicfiss for
U-mode applications.

When programs that use Zicfiss instructions are installed on a processor that
supports the Zicfiss extension but the extension is not enabled at the privilege
mode where the program executes, the program continues to function correctly but
without backward-edge CFI protection as the Zicfiss instructions will revert to
their Zimop/Zcmop-defined behavior.

When programs that use Zicfiss instructions are installed on a processor that
does not support the Zicfiss extension but supports the Zimop and Zcmop
extensions, the programs continues to function correctly but without
backward-edge CFI protection as the Zicfiss instructions will revert to their
Zimop/Zcmop-defined behavior.

On processors that do not support Zimop/Zcmop extensions, all Zimop/Zcmop code
points including those used for Zicfiss instructions may cause an
illegal-instruction exception. Execution of programs that use these instructions
on such machines is not supported.

Activating Zicfiss in M-mode is currently not supported. Additionally, when
S-mode is not implemented, activation in U-mode is also not supported. These
functionalities may be introduced in a future standard extension.
====

<<<

[[SS_PUSH]]
=== Push to the Shadow Stack
A shadow stack push operation is defined as decrement of the `ssp` by `XLEN/8`
followed by a store of the value in the link register to memory at the new top
of the shadow stack.

[wavedrom, ,svg]
....
{reg: [
  {bits:  7, name: 'opcode', attr:'SYSTEM'},
  {bits:  5, name: 'rd', attr:['00000']},
  {bits:  3, name: 'funct3', attr:['100']},
  {bits:  5, name: 'rs1', attr:['00000']},
  {bits:  5, name: 'rs2', attr:['00001', '00101']},
  {bits:  7, name: '1100111', attr:['SSPUSH x1','SSPUSH x5']},
], config:{lanes: 1, hspace:1024}}
....

[wavedrom, ,svg]
....
{reg: [
  {bits:  2, name: 'op', attr:'C1'},
  {bits:  5, name: '00000'},
  {bits:  1, name: '1'},
  {bits:  3, name: 'n[3:1]', attr:['000']},
  {bits:  1, name: '0'},
  {bits:  1, name: '0'},
  {bits:  3, name: '011', attr:['C.SSPUSH x1']},
], config:{lanes: 1, hspace:1024}}
....

Only `x1` and `x5` registers are supported as `rs2` for `SSPUSH`. Zicfiss
provides a 16-bit version of the `SSPUSH x1` instruction using the Zcmop
defined `C.MOP.1` encoding. The `C.SSPUSH x1` expands to `SSPUSH x1`.

The `SSPUSH` instruction and its compressed form `C.SSPUSH` can be used to push
a link register on the shadow stack. The `SSPUSH` and `C.SSPUSH` instructions
perform a store identically to the existing store instructions, with the
difference that the base is implicitly `ssp` and the width is implicitly `XLEN`.

The `SSPUSH` and `C.SSPUSH` instructions require the virtual address in `ssp` to
have a shadow stack attribute (see <<SSMP>>). Correct execution of `SSPUSH` and
`C.SSPUSH` requires that `ssp` refers to idempotent memory. If the memory
referenced by `ssp` is not idempotent, then the `SSPUSH`/`C.SSPUSH` instructions
cause a store/AMO access-fault exception. If the virtual address in `ssp` is not
`XLEN` aligned, then the `SSPUSH`/`C.SSPUSH` instructions cause a store/AMO
access-fault exception.

The operation of the `SSPUSH` and `C.SSPUSH` instructions is as follows:

.`SSPUSH` and `C.SSPUSH` operation
[listing]
----
if (xSSE == 1)
    mem[ssp - (XLEN/8)] = X(src)  # Store src value to ssp - XLEN/8
    ssp = ssp - (XLEN/8)          # decrement ssp by XLEN/8
endif
----

The `ssp` is decremented by `SSPUSH` and `C.SSPUSH` only if the store to the
shadow stack completes successfully.

<<<

[[SS_POP]]
=== Pop from the Shadow Stack

A shadow stack pop operation is defined as an `XLEN` wide read from the
current top of the shadow stack followed by an increment of the `ssp` by
`XLEN/8`.

[wavedrom, ,svg]
....
{reg: [
  {bits:  7, name: 'opcode', attr:'SYSTEM'},
  {bits:  5, name: 'rd',  attr:['00000','00000']},
  {bits:  3, name: 'funct3', attr:['100']},
  {bits:  5, name: 'rs1', attr:['00001','00101']},
  {bits: 12, name: '110011011100', attr:['SSPOPCHK x1','SSPOPCHK x5']},
], config:{lanes: 1, hspace:1024}}
....

[wavedrom, ,svg]
....
{reg: [
  {bits:  2, name: 'op', attr:'C1'},
  {bits:  5, name: '00000'},
  {bits:  1, name: '1'},
  {bits:  3, name: 'n[3:1]', attr:['010']},
  {bits:  1, name: '0'},
  {bits:  1, name: '0'},
  {bits:  3, name: '011', attr:['C.SSPOPCHK x5']},
], config:{lanes: 1, hspace:1024}}
....

Only `x1` and `x5` registers are supported as `rs1` for `SSPOPCHK`. Zicfiss
provides a 16-bit version of the `SSPOPCHK x5` using the Zcmop defined `C.MOP.5`
encoding. The `C.SSPOPCHK x5` expands to `SSPOPCHK x5`.

Programs with a shadow stack push the return address onto the regular stack as
well as the shadow stack in the prologue of non-leaf functions. When returning
from these non-leaf functions, such programs pop the link register from the
regular stack and pop a shadow copy of the link register from the shadow stack.
The two values are then compared. If the values do not match, it is indicative
of a corruption of the return address variable on the regular stack.

The `SSPOPCHK` instruction, and its compressed form `C.SSPOPCHK`, can be used to
pop the shadow return address value from the shadow stack and check that the
value matches the contents of the link register, and if not cause a
software-check exception with `__x__tval` set to "shadow stack fault (code=3)".

While any register may be used as link register, conventionally the `x1` or `x5`
registers are used. The shadow stack instructions are designed to be most
efficient when the `x1` and `x5` registers are used as the link register.

[NOTE]
====
Return-address prediction stacks are a common feature of high-performance
instruction-fetch units, but they require accurate detection of instructions
used for procedure calls and returns to be effective. For RISC-V, hints as to
the instructions' usage are encoded implicitly via the register numbers used.
The return-address stack (RAS) actions to pop and/or push onto the RAS are
specified in Table 2.1 of the Unprivileged specification cite:[UNPRIV].

Using `x1` or `x5` as the link register allows a program to benefit from the
return-address prediction stacks. Additionally, since the shadow stack
instructions are designed around the use of `x1` or `x5` as the link register,
using any other register as a link register would incur the cost of additional
register movements.

Compilers, when generating code with backward-edge CFI, must protect the link
register, e.g., `x1` and/or `x5`, from arbitrary modification by not emitting
unsafe code sequences.
====

<<<

[NOTE]
====
Storing the return address on both stacks preserves the call stack layout and
the ABI, while also allowing for the detection of corruption of the return
address on the regular stack. The prologue and epilogue of a non-leaf function
that uses shadow stacks is as follows:

[listing]
----
    function_entry:
        addi sp,sp,-8  # push link register x1
        sd x1,(sp)     # on regular stack
        sspush x1      # push link register x1 on shadow stack
         :
        ld x1,(sp)     # pop link register x1 from regular stack
        addi sp,sp,8
        sspopchk x1    # fault if x1 not equal to shadow return address
        ret
----

This example illustrates the use of `x1` register as the link register.
Alternatively, the `x5` register may also be used as the link register.

A leaf function, a function that does not itself make function calls, does
not need to spill the link register. Consequently, the return value may be held
in the link register itself for the duration of the leaf function's execution.
====

The `C.SSPOPCHK`, and `SSPOPCHK` instructions perform a load identically to the
existing load instructions, with the difference that the base is implicitly
`ssp` and the width is implicitly `XLEN`.

The `SSPOPCHK` and `C.SSPOPCHK` instructions require the virtual address in
`ssp` to have a shadow stack attribute (see <<SSMP>>). Correct execution of
`SSPOPCHK` and `C.SSPOPCHK` requires that `ssp` refers to idempotent memory. If
the memory reference by `ssp` is not idempotent, then the instructions cause a
store/AMO access-fault exception. If the virtual address in `ssp` is not `XLEN`
aligned, then `SSPOPCHK` and `C.SSPOPCHK` instructions cause a store/AMO
access-fault exception

[NOTE]
====
Misaligned accesses to shadow stack are not required and enforcing alignment is
more secure to detect errors in the program. An access-fault exception is raised
instead of address-misaligned exception in such cases to indicate fatality and
that the instruction must not be emulated by a trap handler.

The `SSPOPCHK` instruction performs a load followed by a check of the loaded
data value with the link register as source. If the check against the link register
faults, and the instruction is restarted by the trap handler, then the instruction
will perform a load again. If the memory from which the load is performed is
non-idempotent, then the second load may cause unexpected side effects.
Instructions that load from the shadow stack require the memory referenced by
`ssp` to be idempotent to avoid such concerns. Locating shadow stacks in
non-idempotent memory, such as non-idempotent device memory, is not an expected
usage, and requiring memory referenced by `ssp` to be idempotent does not pose a
significant restriction.
====

<<<

The operation of the `SSPOPCHK` and `C.SSPOPCHK` instructions is as follows:

.`SSPOPCHK` and `C.SSPOPCHK` operation
[listing]
----
if (xSSE == 1)
    temp = mem[ssp]            # Load temp from address in ssp and
    if temp != X(src)          # Compare temp to value in src and
                               # cause an software-check exception
                               # if they are not bitwise equal.
                               # Only x1 and x5 may be used as src
       Raise software-check exception
    else
       ssp = ssp + (XLEN/8)    # increment ssp by XLEN/8.
    endif
endif
----

If the value loaded from the address in `ssp` does not match the value in `rs1`,
a software-check exception (cause=18) is raised with `__x__tval` set to "shadow
stack fault (code=3)". The software-check exception caused by `SSPOPCHK`/
`C.SSPOPCHK` is lower in priority than a load/store/AMO access-fault exception.

The `ssp` is incremented by `SSPOPCHK` and `C.SSPOPCHK` only if the load from
the shadow stack completes successfully and no software-check exception is
raised.

[NOTE]
====
The use of the compressed instruction `C.SSPUSH x1` to push on the shadow stack
is most efficient when the ABI uses `x1` as the link register, as the link
register may then be pushed without needing a register-to-register move in the
function prologue. To use the compressed instruction `C.SSPOPCHK x5`, the
function should pop the return address from regular stack into the alternate
link register `x5` and use the `C.SSPOPCHK x5` to compare the return address to
the shadow copy stored on the shadow stack. The function then uses `C.JR x5` to
jump to the return address.

[listing]
----
    function_entry:
        c.addi sp,sp,-8  # push link register x1
        c.sd x1,(sp)     # on regular stack
        c.sspush x1      # push link register x1 on shadow stack
         :
        c.ld x5,(sp)     # pop link register x5 from regular stack
        c.addi sp,sp,8
        c.sspopchk x5    # fault if x5 not equal to shadow return address
        c.jr x5
----

====

<<<

[NOTE]
====
Store-to-load forwarding is a common technique employed by high-performance
processor implementations. Zicfiss implementations may prevent forwarding from
a non-shadow-stack store to the `SSPOPCHK` or the `C.SSPOPCHK` instructions. A
non-shadow-stack store causes a fault if done to a page mapped as a shadow
stack. However, such determination may be delayed till the PTE has been examined
and thus may be used to transiently forward the data from such stores to
`SSPOPCHK` or to `C.SSPOPCHK`.
====

[[SSP_READ]]
=== Read `ssp` into a Register

The `SSRDP` instruction is provided to move the contents of `ssp` to a destination
register.

[wavedrom, ,svg]
....
{reg: [
  {bits:  7, name: 'opcode', attr:'SYSTEM'},
  {bits:  5, name: 'rd', attr:['dst']},
  {bits:  3, name: 'funct3', attr:['100']},
  {bits:  5, name: '00000'},
  {bits: 12, name: '110011011100', attr:['SSRDP']},
], config:{lanes: 1, hspace:1024}}
....

Encoding `rd` as `x0` is not supported for `SSRDP`.

The operation of the `SSRDP` instructions is as follows:

.`SSRDP` operation
[listing]
----
if (xSSE == 1)
    X(dst) = ssp
else
    X(dst) = 0
endif
----

[NOTE]
====
The property of Zimop writing 0 to the `rd` when the extension using Zimop is
not implemented or not active may be used by to determine if Zicfiss extension
is active. For example, functions that unwind shadow stacks may skip over the
unwind actions by dynamically detecting if the Zicfiss extension is active.

An example sequence such as the following may be used:

[listing]
    ssrdp t0                      # mv ssp to t0
    beqz t0, zicfiss_not_active   # zero is not a valid shadow stack
                                  # pointer by convention
    # Zicfiss is active
    :
    :
zicfiss_not_active:

To assist with the use of such code sequences, operating systems and runtimes
must not locate shadow stacks at address 0.
====

<<<

[NOTE]
====
A common operation performed on stacks is to unwind them to support constructs
like `setjmp`/`longjmp`, C++ exception handling, etc. A program that uses shadow
stacks must unwind the shadow stack in addition to the stack used to store data.
The unwind function must verify that it does not accidentally unwind past the
bounds of the shadow stack. Shadow stacks are expected to be bounded on each end
using guard pages. A guard page for a stack is a page that is not accessible by
the process that owns the stack. To detect if the unwind occurs past the bounds
of the shadow stack, the unwind may be done in maximal increments of 4 KiB,
testing whether the `ssp` is still pointing to a shadow stack page or has
unwound into the guard page. The following examples illustrate the use of shadow
stack instructions to unwind a shadow stack. This example assumes that the
`setjmp` function itself does not push on to the shadow stack (being a leaf
function, it is not required to).

[listing]
setjmp() {
    :
    :
    // read and save the shadow stack pointer to jmp_buf
    asm("ssrdp %0" : "=r"(cur_ssp):);
    jmp_buf->saved_ssp = cur_ssp;
    :
    :
}
longjmp() {
    :
    // Read current shadow stack pointer and
    // compute number of call frames to unwind
    asm("ssrdp %0" : "=r"(cur_ssp):);
    // Skip the unwind if backward-edge CFI not active
    asm("beqz %0, back_cfi_not_active" : "=r"(cur_ssp):);
    // Unwind the frames in a loop
    while ( jmp_buf->saved_ssp > cur_ssp ) {
        // advance by a maximum of 4K at a time to avoid
        // unwinding past bounds of the shadow stack
        cur_ssp = ( (jmp_buf->saved_ssp - cur_ssp) >= 4096 ) ?
                  (cur_ssp + 4096) : jmp_buf->saved_ssp;
        asm("csrw ssp, %0" : :  "r" (cur_ssp));
        // Test if unwound past the shadow stack bounds
        asm("sspush x5");
        asm("sspopchk x5");
    }
back_cfi_not_active:
    :
}
====

<<<

[[SSAMOSWAP]]
=== Atomic Swap from a Shadow Stack Location

[wavedrom, , ]
....
{reg: [
  {bits:  7, name: 'opcode', attr:'AMO'},
  {bits:  5, name: 'rd', attr:'dest'},
  {bits:  3, name: 'funct3', attr:['010', '011']},
  {bits:  5, name: 'rs1', attr:'addr'},
  {bits:  5, name: 'rs2', attr:'src'},
  {bits:  1, name: 'rl'},
  {bits:  1, name: 'aq'},
  {bits:  5, name: '01001', attr:['SSAMOSWAP.W', 'SSAMOSWAP.D']},
], config:{lanes: 1, hspace:1024}}
....

For RV32, `SSAMOSWAP.W` atomically loads a 32-bit data value from address of a
shadow stack location in `rs1`, puts the loaded value into register `rd`, and
stores the 32-bit value held in `rs2` to the original address in `rs1`.
`SSAMOSWAP.D` (RV64 only) is similar to `SSAMOSWAP.W` but operates on 64-bit
data values.

.`SSAMOSWAP.W` for RV32 and `SSAMOSWAP.D` (RV64 only) operation
[listing]
----
  if privilege_mode != M && menvcfg.SSE == 0
      raise illegal-instruction exception
  if S-mode not implemented
      raise illegal-instruction exception
  else if privilege_mode == U && senvcfg.SSE == 0
      raise illegal-instruction exception
  else if privilege_mode == VS && henvcfg.SSE == 0
      raise virtual instruction exception
  else if privilege_mode == VU && senvcfg.SSE == 0
      raise virtual instruction exception
  else
      X(rd) = mem[X(rs1)]
      mem[X(rs1)] = X(rs2)
  endif
----

For RV64, `SSAMOSWAP.W` atomically loads a 32-bit data value from address of a
shadow stack location in `rs1`, sign-extends the loaded value and puts it in
`rd`, and stores the lower 32 bits of the value held in `rs2` to the original
address in `rs1`.

.`SSAMOSWAP.W` for RV64
[listing]
----
  if privilege_mode != M && menvcfg.SSE == 0
      raise illegal-instruction exception
  if S-mode not implemented
      raise illegal-instruction exception
  else if privilege_mode == U && senvcfg.SSE == 0
      raise illegal-instruction exception
  else if privilege_mode == VS && henvcfg.SSE == 0
      raise virtual instruction exception
  else if privilege_mode == VU && senvcfg.SSE == 0
      raise virtual instruction exception
  else
      temp[31:0] = mem[X(rs1)]
      X(rd) = SignExtend(temp[31:0])
      mem[X(rs1)] = X(rs2)[31:0]
  endif
----

<<<

If the memory referenced by `rs1` is not idempotent, then `SSAMOSWAP.W/D`
causes a store/AMO access-fault exception.

Just as for AMOs in the A extension, `SSAMOSWAP.W/D` requires that the address
held in `rs1` be naturally aligned to the size of the operand (i.e., eight-byte
aligned for __doublewords__, and four-byte aligned for __words__). The same
exception options apply if the address is not naturally aligned.

Just as for AMOs in the A extension, `SSAMOSWAP.W/D` optionally provides
release consistency semantics, using the `aq` and `rl` bits, to help implement
multiprocessor synchronization. An `SSAMOSWAP.W/D` operation has acquire
semantics if `aq=1` and release semantics if `rl=1`.

The `SSAMOSWAP.W/D` instructions require the PMA of the accessed memory range to
provide AMOSwap level support.

[NOTE]
====
Stack switching is a common operation in user programs as well as supervisor
programs. When a stack switch is performed the stack pointer of the currently
active stack is saved into a context data structure and the new stack is made
active by loading a new stack pointer from a context data structure.

When shadow stacks are active for a program, the program needs to additionally
switch the shadow stack pointer. If the pointer to the top of the deactivated
shadow stack is held in a context data structure, then it  may be susceptible to
memory corruption vulnerabilities. To protect the pointer value, the program may
store it at the top of the deactivated shadow stack itself and thereby create a
checkpoint. A legal checkpoint is defined as one that holds a value of `X`,
where `X` is the address at which the checkpoint is positioned on the shadow
stack.
====

[NOTE]
====
An example sequence to restore the shadow stack pointer from the new shadow
stack and save the old shadow stack pointer on the old shadow stack is as
follows:

[listing]
----
# a0 hold pointer to top of new shadow stack to switch to
stack_switch:
   ssrdp ra
   beqz ra, 2f                    # skip if Zicfiss not active
   ssamoswap.d ra, x0,  (a0)      # ra=*[a0] and *[a0]=0
   beq         ra, a0,  1f        # [a0] must be == [ra]
   unimp                          # else crash
1: addi        ra, ra,  XLEN/8    # pop the checkpoint
   csrrw       ra, ssp, ra        # swap ssp: ra=ssp, ssp=ra
   addi        ra, ra,  -(XLEN/8) # checkpoint = "old ssp - XLEN/8"
   ssamoswap.d x0, ra,  (ra)      # Save checkpoint at "old ssp - XLEN/8" 
2:
----

This sequence uses the `ra` register. If the privilege mode at which this
sequence is executed can be interrupted, then the trap handler should save the
`ra` on the shadow stack itself. There it is guarded against tampering and
can be restored prior to returning from the trap.

When a new shadow stack is created by the supervisor, it needs to store a
checkpoint at the highest address on that stack. This enables the shadow stack
pointer to be switched using the process outlined in this note. The
`SSAMOSWAP.W/D` instruction can be used to store this checkpoint. When the old
value at the memory location operated on by `SSAMOSWAP.W/D` is not required,
`rd` can be set to `x0`.
====

<<<

[[SSMP]]
=== Shadow Stack Memory Protection

To protect shadow stack memory, the memory is associated with a new page type –
the Shadow Stack (SS) page – in the single-stage and VS-stage page tables. The
encoding `R=0`, `W=1`, and `X=0`, is defined to represent an SS page. When
`menvcfg.SSE=0`, this encoding remains reserved. Similarly, when `V=1` and
`henvcfg.SSE=0`, this encoding remains reserved at `VS` and `VU` levels.

If `satp.MODE` (or `vsatp.MODE` when `V=1`) is set to `Bare` and the effective
privilege mode is below M, shadow stack memory accesses are prohibited, and
shadow stack instructions will raise a store/AMO access-fault exception. When
the effective privilege mode is M, any memory access by an `SSAMOSWAP.W/D`
instruction will result in a store/AMO access-fault exception.

Memory mapped as an SS page cannot be written to by instructions other than
`SSAMOSWAP.W/D`, `SSPUSH`, and `C.SSPUSH`. Attempts will raise a store/AMO
page-fault exception. Implicit accesses, including instruction fetches to an SS
page, are not permitted. Such accesses will raise an access-fault exception
appropriate to the access type. However, the shadow stack is readable by all
instructions that only load from memory.

[NOTE]
====
Stores to shadow stack pages by instructions other than `SSAMOSWAP`, `SSPUSH`,
and `C.SSPUSH` will trigger a store/AMO access-fault exception, not a store/AMO
page-fault exception, signaling a fatal error. A store/AMO page-fault suggests
that the operating system could address and rectify the fault, which is not
feasible in this scenario. Hence, the page fault handler must decode the opcode
of the faulting instruction to discern whether the fault was caused by a
non-shadow-stack instruction writing to an SS page (a fatal condition) or by a
shadow stack instruction to a non-resident page (a recoverable condition). The
performance-critical nature of operating system page fault handlers necessitates
triggering an access-fault instead of a page fault, allowing for a
straightforward distinction between fatal conditions and recoverable faults.

Operating systems must ensure that no writable, non-shadow-stack alias virtual
address mappings exist for the physical memory backing the shadow stack.
Furthermore, in systems where an address-misaligned exception supersedes the
access-fault exception, handlers emulating misaligned stores must be designed to
cause an access-fault exception when the store is directed to a shadow stack
page.

All instructions that perform load operations are allowed to read from the
shadow stack. This feature facilitates debugging and performance profiling by
allowing examination of the link register values backed up in the shadow stack.

As of the drafting of this specification, instruction fetches are the sole type
of implicit access subjected to single- or VS-stage address translation.
====

The access type is classified as a store/AMO in the event of an access-fault,
page-fault, or guest-page fault exception triggered by shadow stack instructions.

<<<

Shadow stack instructions are restricted to accessing shadow stack
(`pte.xwr=010b`) pages. Should a shadow stack instruction access a page that is
not designated as a shadow stack page and is not marked as read-only
(`pte.xwr=001`), a store/AMO access-fault exception will be invoked. Conversely,
if the page being accessed by a shadow stack instruction is a read-only page, a
store/AMO page-fault exception will be triggered.

[NOTE]
====
Shadow stack loads and stores will trigger a store/AMO page-fault if the
accessed page is read-only, to support copy-on-write (COW) of a shadow stack
page. If the page has been marked read-only for COW tracking, the page fault
handler responds by creating a copy of the page and updates the `pte.xwr` to
`010b`, thereby designating each copy as a shadow stack page. Conversely, if
the access targets a genuinely read-only page, the fault being reported as a
store/AMO page-fault signals to the operating system that the fault is fatal
and non-recoverable. Reporting the fault as a store/AMO page-fault, even for
`SSPOPCHK` initiated memory access, aids in the determination of fatality; if
these were reported as load page-faults, access to a truly read-only page
might be mistakenly treated as a recoverable fault, leading to the faulting
instruction being retried indefinitely. The PTE does not provide a read-only
shadow stack encoding.

Attempts by shadow stack instructions to access pages marked as read-write,
read-write-execute, read-execute, or execute-only result in a store/AMO
access-fault exception, similarly indicating a fatal condition.

Shadow stacks should be bounded at each end by guard pages to prevent accidental
underflows or overflows from one shadow stack into another. Conventionally, a
guard page for a stack is a page that is not accessible by the process that owns
the stack.
====

The `U` and `SUM` bit enforcement is performed normally for shadow stack
instruction initiated memory accesses. The state of the `MXR` bit does not
affect read access to a shadow stack page as the shadow stack page is always
readable by all instructions that load from memory.

The G-stage address translation and protections remain unaffected by the Zicfiss
extension. The `xwr == 010b` encoding in the G-stage PTE remains reserved. When
G-stage page tables are active, the shadow stack instructions that access memory
require the G-stage page table to have read-write permission for the accessed
memory; else a store/AMO guest-page fault exception is raised.

[NOTE]
====
A future extension may define a shadow stack encoding in the G-stage page table
to support use cases such as a hypervisor enforcing shadow stack protections for
its guests.
====

Svpbmt and Svnapot extensions are supported for shadow stack pages.

The PMA checks are extended to require memory referenced by shadow stack
instructions to be idempotent. The PMP checks are extended to require read-write
permission for memory accessed by shadow stack instructions. If the PMP does not
provide read-write permissions or if the accessed memory is not idempotent then
a store/AMO access-fault exception is raised.
